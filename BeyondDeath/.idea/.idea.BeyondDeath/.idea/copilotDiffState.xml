<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Projectile.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Projectile.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;public class Projectile : MonoBehaviour&#10;{&#10;    private Vector2 _direction;&#10;    private float _speed;&#10;    private float _damage;&#10;    private Rigidbody2D _rb;&#10;    [SerializeField] private float lifeTime = 3f;&#10;    private int _ownerLayer; // Layer del character que lanza el proyectil&#10;&#10;    //Inicializacion desde el enemigo o player&#10;    public void Init(Vector2 direction, float speed, float damage, int ownerLayer)&#10;    {&#10;        _direction = direction.normalized;&#10;        _speed = speed;&#10;        _damage = damage;&#10;        _ownerLayer = ownerLayer;&#10;        if (_rb != null)&#10;        {&#10;            _rb.linearVelocity = _direction * _speed;&#10;        }&#10;    }&#10;&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (_rb != null)&#10;            _rb.linearVelocity = Vector2.zero;&#10;    }&#10;&#10;    private void OnTriggerEnter2D(Collider2D collision)&#10;    {&#10;        // Evita que el proyectil dañe al owner&#10;        if (collision.gameObject.layer == _ownerLayer)&#10;            return;&#10;        // Los proyectiles hacen daño si el layer es Player o Enemy&#10;        if (collision.gameObject.layer == LayerMask.NameToLayer(&quot;Player&quot;) || collision.gameObject.layer == LayerMask.NameToLayer(&quot;Enemy&quot;))&#10;        {&#10;            Character character = collision.GetComponentInParent&lt;Character&gt;();&#10;            if (character != null)&#10;                character.TakeDamage(_damage);&#10;            DestroyProjectile();&#10;        }&#10;        //Se destruyen si choca con algo que no sea enemigo o jugador&#10;        else&#10;        {&#10;            DestroyProjectile();&#10;        }&#10;    }&#10;&#10;    public void DestroyProjectile()&#10;    {&#10;        if (gameObject.activeSelf)&#10;            gameObject.SetActive(false);&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class Projectile : MonoBehaviour&#10;{&#10;    private Vector2 _direction;&#10;    private float _speed;&#10;    private float _damage;&#10;    private Rigidbody2D _rb;&#10;    [SerializeField] private float lifeTime = 3f;&#10;    private int _ownerLayer; // Layer del character que lanza el proyectil&#10;&#10;    //Inicializacion desde el enemigo o player&#10;    public void Init(Vector2 direction, float speed, float damage, int ownerLayer)&#10;    {&#10;        _direction = direction.normalized;&#10;        _speed = speed;&#10;        _damage = damage;&#10;        _ownerLayer = ownerLayer;&#10;        if (_rb != null)&#10;        {&#10;            _rb.linearVelocity = _direction * _speed;&#10;        }&#10;    }&#10;&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (_rb != null)&#10;            _rb.linearVelocity = Vector2.zero;&#10;    }&#10;&#10;    private void OnTriggerEnter2D(Collider2D collision)&#10;    {&#10;        // Evita que el proyectil dañe al owner&#10;        if (collision.gameObject.layer == _ownerLayer)&#10;            return;&#10;        // Los proyectiles hacen daño si el layer es Player o Enemy&#10;        if (collision.gameObject.layer == LayerMask.NameToLayer(&quot;Player&quot;) || collision.gameObject.layer == LayerMask.NameToLayer(&quot;Enemy&quot;))&#10;        {&#10;            Character character = collision.GetComponentInParent&lt;Character&gt;();&#10;            if (character != null)&#10;                character.TakeDamage(_damage);&#10;            DestroyProjectile();&#10;        }&#10;        //Se destruyen si choca con algo que no sea enemigo o jugador&#10;        else&#10;        {&#10;            DestroyProjectile();&#10;        }&#10;    }&#10;&#10;    public void DestroyProjectile()&#10;    {&#10;        if (gameObject.activeSelf)&#10;            gameObject.SetActive(false);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con dirección, velocidad y daño&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage, gameObject.layer);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con dirección, velocidad y daño&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage, gameObject.layer);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>