<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/EnemyMovable.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/EnemyMovable.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;[RequireComponent(typeof(Rigidbody2D), typeof(Collider2D))]&#10;public class EnemyMovable : Character&#10;{&#10;    [SerializeField] private GameObject player;&#10;    [SerializeField] private float speed = 3f;&#10;    [SerializeField] private Animator anim;&#10;    [SerializeField] private SpriteRenderer sprite;&#10;&#10;    private enum FacingDirection { Left, Right, Up, Down, UpLeft, UpRight, DownLeft, DownRight }&#10;    private FacingDirection _facingDirection;&#10;    private CharacterState _state;&#10;    &#10;    private Rigidbody2D _rb;&#10;    private Coroutine _attackCoroutine;&#10;    &#10;    private bool _isAttacking;&#10;    private bool _canAttack = true;&#10;    private bool _isDead;&#10;    &#10;    //nombre EXACTOS de los estados&#10;    //Estados de izquierda y derecha&#10;    private readonly int _idleAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle&quot;);&#10;    private readonly int _walkAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk&quot;);&#10;    private readonly int _attackAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack&quot;);&#10;    private readonly int _hitAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit&quot;);&#10;    private readonly int _deathAnimState = Animator.StringToHash(&quot;EnemyMelee_Death&quot;);&#10;    &#10;    //Estados de front y back (w y s)&#10;    private readonly int _idleFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_Front&quot;);&#10;    private readonly int _idleBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_Back&quot;);&#10;    private readonly int _idleUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_UpRight&quot;);&#10;    private readonly int _idleDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_DownRight&quot;);&#10;    &#10;    private readonly int _walkFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_Front&quot;);&#10;    private readonly int _walkBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_Back&quot;);&#10;    private readonly int _walkUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_UpRight&quot;);&#10;    private readonly int _walkDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_DownRight&quot;);&#10;    &#10;    private readonly int _attackFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_Front&quot;);&#10;    private readonly int _attackBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_Back&quot;);&#10;    private readonly int _attackUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_UpRight&quot;);&#10;    private readonly int _attackDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_DownRight&quot;);&#10;    &#10;    private readonly int _deathFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_Front&quot;);&#10;    private readonly int _deathBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_Back&quot;);&#10;    private readonly int _deathUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_UpRight&quot;);&#10;    private readonly int _deathDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_DownRight&quot;);&#10;    &#10;    private readonly int _hitFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_Front&quot;);&#10;    private readonly int _hitBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_Back&quot;);&#10;    private readonly int _hitUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_UpRight&quot;);&#10;    private readonly int _hitDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_DownRight&quot;);&#10;    &#10;    &#10;    //Inicializar enemy&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        if(anim == null) anim = GetComponent&lt;Animator&gt;();&#10;        if(sprite == null) sprite = GetComponent&lt;SpriteRenderer&gt;();&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        SetHealthMax(100f);&#10;        SetDamage(17f);&#10;        _state = CharacterState.Idle;&#10;    }&#10;&#10;    //Calcular posicion hacia el player y moverse hasta el&#10;    private void Update()&#10;    {&#10;        if(_isDead || player == null) return;&#10;&#10;        if (!_isAttacking)&#10;            UpdateRotation();&#10;&#10;        float distance = Vector2.Distance(transform.position, player.transform.position);&#10;        &#10;        //Atacar al player&#10;        if (distance &lt;= GetAttackDistance())&#10;        {&#10;            _rb.linearVelocity = Vector2.zero;&#10;            if (_canAttack &amp;&amp; !_isAttacking)&#10;                Attack();&#10;        }&#10;        else&#10;            MoveToPlayer();&#10;    }&#10;    &#10;    //Rotar enemy en base a la direccion en la que esta el player&#10;    private void UpdateRotation()&#10;    {&#10;        Vector2 direction = (player.transform.position - transform.position).normalized;&#10;        float absX = Mathf.Abs(direction.x);&#10;        float absY = Mathf.Abs(direction.y);&#10;&#10;        // --- CÓDIGO ORIGINAL (8 direcciones, ahora comentado) ---&#10;        /*&#10;        //Diagonales&#10;        if (absX &gt; 0.5f &amp;&amp; absY &gt; 0.5f)&#10;        {&#10;            if (direction.x &gt; 0 &amp;&amp; direction.y &gt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.UpRight;&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;            }&#10;            else if (direction.x &lt; 0 &amp;&amp; direction.y &gt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.UpLeft;&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;            }&#10;            else if (direction.x &gt; 0 &amp;&amp; direction.y &lt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.DownRight;&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;            }&#10;            else if (direction.x &lt; 0 &amp;&amp; direction.y &lt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.DownLeft;&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;            }&#10;        //Horizontales&#10;        } else if (absX &gt; absY)&#10;        {&#10;            _facingDirection = direction.x &lt; 0 ? FacingDirection.Left : FacingDirection.Right;&#10;            sprite.flipX = _facingDirection == FacingDirection.Left;&#10;            anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;        }&#10;        //verticales&#10;        else&#10;        {&#10;            _facingDirection = direction.y &gt; 0 ? FacingDirection.Up : FacingDirection.Down;&#10;            anim.CrossFadeInFixedTime(_facingDirection == FacingDirection.Up&#10;                ? _walkFrontAnimState : _walkBackAnimState, 0.1f);&#10;        }&#10;        */&#10;        // --- FIN CÓDIGO ORIGINAL ---&#10;&#10;        // --- SOLO 4 DIRECCIONES ---&#10;        if (absX &gt; absY)&#10;        {&#10;            // Movimiento horizontal&#10;            _facingDirection = direction.x &lt; 0 ? FacingDirection.Left : FacingDirection.Right;&#10;            sprite.flipX = _facingDirection == FacingDirection.Left;&#10;            anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;        }&#10;        else&#10;        {&#10;            // Movimiento vertical&#10;            _facingDirection = direction.y &gt; 0 ? FacingDirection.Up : FacingDirection.Down;&#10;            anim.CrossFadeInFixedTime(_facingDirection == FacingDirection.Up&#10;                ? _walkFrontAnimState : _walkBackAnimState, 0.1f);&#10;        }&#10;    }&#10;&#10;    //Moverse hacia el player&#10;    private void MoveToPlayer()&#10;    {&#10;        if(_isAttacking || _state == CharacterState.Hurt || _state == CharacterState.Die) return;&#10;        &#10;        Vector2 direction = (player.transform.position - transform.position).normalized;&#10;        float absX = Mathf.Abs(direction.x);&#10;        float absY = Mathf.Abs(direction.y);&#10;        Vector2 moveDir;&#10;        // --- CÓDIGO ORIGINAL (comentado) ---&#10;        // _rb.linearVelocity = direction * speed;&#10;        // --- SOLO 4 DIRECCIONES ---&#10;        if (absX &gt; absY)&#10;            moveDir = new Vector2(Mathf.Sign(direction.x), 0);&#10;        else&#10;            moveDir = new Vector2(0, Mathf.Sign(direction.y));&#10;        _rb.linearVelocity = moveDir * speed;&#10;        _state = CharacterState.Walk;&#10;    }&#10;&#10;&#10;    //Atacar al player&#10;    public override void Attack()&#10;    {&#10;        if(_attackCoroutine != null)&#10;            StopCoroutine(_attackCoroutine);&#10;        _attackCoroutine = StartCoroutine(AttackRoutine());&#10;    }&#10;&#10;    private IEnumerator AttackRoutine()&#10;    {&#10;        _isAttacking = true;&#10;        _canAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        _state = CharacterState.Attack;&#10;        Vector2 offset = hitAnchor.localPosition;&#10;        const float range = 0.7f;&#10;        &#10;        &#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                offset = new Vector2(-range, 0);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                offset = new Vector2(range, 0);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_attackFrontAnimState, 0f);&#10;                offset = new Vector2(0, range);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_attackBackAnimState, 0f);&#10;                offset = new Vector2(0, -range);&#10;                break;&#10;            case  FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                offset = new Vector2(-range, range);&#10;                break;&#10;            case  FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                offset = new Vector2(range, range);&#10;                break;&#10;            case  FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                offset = new Vector2(-range, -range);&#10;                break;&#10;            case  FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                offset = new Vector2(range, -range);&#10;                break;&#10;        }&#10;        &#10;        yield return new WaitForSeconds(0.15f); //Delay para permitir la animación antes del danio&#10;&#10;        //Area del ataque&#10;        if (hitAnchor != null)&#10;        {&#10;            hitAnchor.localPosition = offset;&#10;            &#10;            Vector2 boxSize = hitSize;&#10;            if(_facingDirection == FacingDirection.Up || _facingDirection == FacingDirection.Down)&#10;                boxSize = new Vector2(hitSize.y, hitSize.x);&#10;            &#10;            Collider2D[] hits = Physics2D.OverlapBoxAll(hitAnchor.position, boxSize, 0);&#10;            foreach (Collider2D col in hits)&#10;            {&#10;                if ((col.CompareTag(&quot;Player&quot;)))&#10;                {&#10;                    Character playerChar = col.GetComponentInParent&lt;Character&gt;();&#10;                    if(playerChar != null)&#10;                        playerChar.TakeDamage(GetDamage());&#10;                }&#10;            }&#10;        }&#10;        &#10;        //Fin de animación de ataque&#10;        yield return new WaitForSeconds(GetAttackCooldown());&#10;        _isAttacking = false;&#10;        _canAttack = true;&#10;        _attackCoroutine = null;&#10;        &#10;        //Hacer que el enemigo pueda volver a moverse&#10;        float distance = Vector2.Distance(transform.position, player.transform.position);&#10;        if (distance &gt; GetAttackDistance())&#10;        {&#10;            _state = CharacterState.Walk;&#10;        }&#10;        else&#10;        {&#10;            _state = CharacterState.Idle;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;&#10;    //Recibir danio si el player le ataca&#10;    public override void TakeDamage(float dmg)&#10;    {&#10;        if (_isDead)&#10;            return;&#10;&#10;        if (_isAttacking)&#10;        {&#10;            StopCoroutine(_attackCoroutine);&#10;            _isAttacking = false;&#10;            _canAttack = true;&#10;        }&#10;        &#10;        SetHealthActual(GetHealthActual() - dmg);&#10;        &#10;        if (GetHealthActual() &lt;= 0f)&#10;            Die();&#10;        else&#10;        {&#10;            _state = CharacterState.Hurt;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_hitFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_hitBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;            _rb.linearVelocity = Vector2.zero;&#10;            StartCoroutine(Recover());&#10;        }&#10;    }&#10;&#10;    //Tiempo que el enemy tarda en recuperarse del golpe&#10;    private IEnumerator Recover()&#10;    {&#10;        yield return new WaitForSeconds(0.4f);&#10;            _state = CharacterState.Idle;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;    }&#10;&#10;    //El enemy muere&#10;    public override void Die()&#10;    {&#10;        _isDead = true;&#10;        _state = CharacterState.Die;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_deathFrontAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_deathBackAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;        }&#10;        Destroy(gameObject, 2f);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;[RequireComponent(typeof(Rigidbody2D), typeof(Collider2D))]&#10;public class EnemyMovable : Character&#10;{&#10;    [SerializeField] private GameObject player;&#10;    [SerializeField] private float speed = 3f;&#10;    [SerializeField] private Animator anim;&#10;    [SerializeField] private SpriteRenderer sprite;&#10;&#10;    private enum FacingDirection { Left, Right, Up, Down, UpLeft, UpRight, DownLeft, DownRight }&#10;    private FacingDirection _facingDirection;&#10;    private CharacterState _state;&#10;    &#10;    private Rigidbody2D _rb;&#10;    private Coroutine _attackCoroutine;&#10;    &#10;    private bool _isAttacking;&#10;    private bool _canAttack = true;&#10;    private bool _isDead;&#10;    &#10;    //nombre EXACTOS de los estados&#10;    //Estados de izquierda y derecha&#10;    private readonly int _idleAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle&quot;);&#10;    private readonly int _walkAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk&quot;);&#10;    private readonly int _attackAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack&quot;);&#10;    private readonly int _hitAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit&quot;);&#10;    private readonly int _deathAnimState = Animator.StringToHash(&quot;EnemyMelee_Death&quot;);&#10;    &#10;    //Estados de front y back (w y s)&#10;    private readonly int _idleFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_Front&quot;);&#10;    private readonly int _idleBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_Back&quot;);&#10;    private readonly int _idleUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_UpRight&quot;);&#10;    private readonly int _idleDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Idle_DownRight&quot;);&#10;    &#10;    private readonly int _walkFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_Front&quot;);&#10;    private readonly int _walkBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_Back&quot;);&#10;    private readonly int _walkUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_UpRight&quot;);&#10;    private readonly int _walkDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Walk_DownRight&quot;);&#10;    &#10;    private readonly int _attackFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_Front&quot;);&#10;    private readonly int _attackBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_Back&quot;);&#10;    private readonly int _attackUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_UpRight&quot;);&#10;    private readonly int _attackDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Attack_DownRight&quot;);&#10;    &#10;    private readonly int _deathFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_Front&quot;);&#10;    private readonly int _deathBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_Back&quot;);&#10;    private readonly int _deathUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_UpRight&quot;);&#10;    private readonly int _deathDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Death_DownRight&quot;);&#10;    &#10;    private readonly int _hitFrontAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_Front&quot;);&#10;    private readonly int _hitBackAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_Back&quot;);&#10;    private readonly int _hitUpRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_UpRight&quot;);&#10;    private readonly int _hitDownRightAnimState = Animator.StringToHash(&quot;EnemyMelee_Hit_DownRight&quot;);&#10;    &#10;    &#10;    //Inicializar enemy&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        if(anim == null) anim = GetComponent&lt;Animator&gt;();&#10;        if(sprite == null) sprite = GetComponent&lt;SpriteRenderer&gt;();&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        SetHealthMax(100f);&#10;        SetDamage(17f);&#10;        _state = CharacterState.Idle;&#10;    }&#10;&#10;    //Calcular posicion hacia el player y moverse hasta el&#10;    private void Update()&#10;    {&#10;        if(_isDead || player == null) return;&#10;&#10;        if (!_isAttacking)&#10;            UpdateRotation();&#10;&#10;        float distance = Vector2.Distance(transform.position, player.transform.position);&#10;        &#10;        //Atacar al player&#10;        if (distance &lt;= GetAttackDistance())&#10;        {&#10;            _rb.linearVelocity = Vector2.zero;&#10;            if (_canAttack &amp;&amp; !_isAttacking)&#10;                Attack();&#10;        }&#10;        else&#10;            MoveToPlayer();&#10;    }&#10;    &#10;    //Rotar enemy en base a la direccion en la que esta el player&#10;    private void UpdateRotation()&#10;    {&#10;        Vector2 direction = (player.transform.position - transform.position).normalized;&#10;        float absX = Mathf.Abs(direction.x);&#10;        float absY = Mathf.Abs(direction.y);&#10;&#10;        // --- CÓDIGO ORIGINAL (8 direcciones, ahora comentado) ---&#10;        /*&#10;        //Diagonales&#10;        if (absX &gt; 0.5f &amp;&amp; absY &gt; 0.5f)&#10;        {&#10;            if (direction.x &gt; 0 &amp;&amp; direction.y &gt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.UpRight;&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;            }&#10;            else if (direction.x &lt; 0 &amp;&amp; direction.y &gt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.UpLeft;&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;            }&#10;            else if (direction.x &gt; 0 &amp;&amp; direction.y &lt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.DownRight;&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;            }&#10;            else if (direction.x &lt; 0 &amp;&amp; direction.y &lt; 0)&#10;            {&#10;                _facingDirection = FacingDirection.DownLeft;&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;            }&#10;        //Horizontales&#10;        } else if (absX &gt; absY)&#10;        {&#10;            _facingDirection = direction.x &lt; 0 ? FacingDirection.Left : FacingDirection.Right;&#10;            sprite.flipX = _facingDirection == FacingDirection.Left;&#10;            anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;        }&#10;        //verticales&#10;        else&#10;        {&#10;            _facingDirection = direction.y &gt; 0 ? FacingDirection.Up : FacingDirection.Down;&#10;            anim.CrossFadeInFixedTime(_facingDirection == FacingDirection.Up&#10;                ? _walkFrontAnimState : _walkBackAnimState, 0.1f);&#10;        }&#10;        */&#10;        // --- FIN CÓDIGO ORIGINAL ---&#10;&#10;        // --- SOLO 4 DIRECCIONES ---&#10;        if (absX &gt; absY)&#10;        {&#10;            // Movimiento horizontal&#10;            _facingDirection = direction.x &lt; 0 ? FacingDirection.Left : FacingDirection.Right;&#10;            sprite.flipX = _facingDirection == FacingDirection.Left;&#10;            anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;        }&#10;        else&#10;        {&#10;            // Movimiento vertical&#10;            _facingDirection = direction.y &gt; 0 ? FacingDirection.Up : FacingDirection.Down;&#10;            anim.CrossFadeInFixedTime(_facingDirection == FacingDirection.Up&#10;                ? _walkFrontAnimState : _walkBackAnimState, 0.1f);&#10;        }&#10;    }&#10;&#10;    //Moverse hacia el player&#10;    private void MoveToPlayer()&#10;    {&#10;        if(_isAttacking || _state == CharacterState.Hurt || _state == CharacterState.Die) return;&#10;        &#10;        Vector2 direction = (player.transform.position - transform.position).normalized;&#10;        float absX = Mathf.Abs(direction.x);&#10;        float absY = Mathf.Abs(direction.y);&#10;        Vector2 moveDir;&#10;        // --- CÓDIGO ORIGINAL (comentado) ---&#10;        // _rb.linearVelocity = direction * speed;&#10;        // --- SOLO 4 DIRECCIONES ---&#10;        if (absX &gt; absY)&#10;            moveDir = new Vector2(Mathf.Sign(direction.x), 0);&#10;        else&#10;            moveDir = new Vector2(0, Mathf.Sign(direction.y));&#10;        _rb.linearVelocity = moveDir * speed;&#10;        _state = CharacterState.Walk;&#10;    }&#10;&#10;&#10;    //Atacar al player&#10;    public override void Attack()&#10;    {&#10;        if(_attackCoroutine != null)&#10;            StopCoroutine(_attackCoroutine);&#10;        _attackCoroutine = StartCoroutine(AttackRoutine());&#10;    }&#10;&#10;    private IEnumerator AttackRoutine()&#10;    {&#10;        _isAttacking = true;&#10;        _canAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        _state = CharacterState.Attack;&#10;        Vector2 offset = hitAnchor.localPosition;&#10;        const float range = 0.7f;&#10;        &#10;        &#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                offset = new Vector2(-range, 0);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                offset = new Vector2(range, 0);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_attackFrontAnimState, 0f);&#10;                offset = new Vector2(0, range);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_attackBackAnimState, 0f);&#10;                offset = new Vector2(0, -range);&#10;                break;&#10;            case  FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                offset = new Vector2(-range, range);&#10;                break;&#10;            case  FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                offset = new Vector2(range, range);&#10;                break;&#10;            case  FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                offset = new Vector2(-range, -range);&#10;                break;&#10;            case  FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                offset = new Vector2(range, -range);&#10;                break;&#10;        }&#10;        &#10;        yield return new WaitForSeconds(0.15f); //Delay para permitir la animación antes del danio&#10;&#10;        //Area del ataque&#10;        if (hitAnchor != null)&#10;        {&#10;            hitAnchor.localPosition = offset;&#10;            &#10;            Vector2 boxSize = hitSize;&#10;            if(_facingDirection == FacingDirection.Up || _facingDirection == FacingDirection.Down)&#10;                boxSize = new Vector2(hitSize.y, hitSize.x);&#10;            &#10;            Collider2D[] hits = Physics2D.OverlapBoxAll(hitAnchor.position, boxSize, 0);&#10;            foreach (Collider2D col in hits)&#10;            {&#10;                if ((col.CompareTag(&quot;Player&quot;)))&#10;                {&#10;                    Character playerChar = col.GetComponentInParent&lt;Character&gt;();&#10;                    if(playerChar != null)&#10;                        playerChar.TakeDamage(GetDamage());&#10;                }&#10;            }&#10;        }&#10;        &#10;        //Fin de animación de ataque&#10;        yield return new WaitForSeconds(GetAttackCooldown());&#10;        _isAttacking = false;&#10;        _canAttack = true;&#10;        _attackCoroutine = null;&#10;        &#10;        //Hacer que el enemigo pueda volver a moverse&#10;        float distance = Vector2.Distance(transform.position, player.transform.position);&#10;        if (distance &gt; GetAttackDistance())&#10;        {&#10;            _state = CharacterState.Walk;&#10;        }&#10;        else&#10;        {&#10;            _state = CharacterState.Idle;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;&#10;    //Recibir danio si el player le ataca&#10;    public override void TakeDamage(float dmg)&#10;    {&#10;        if (_isDead)&#10;            return;&#10;&#10;        if (_isAttacking)&#10;        {&#10;            StopCoroutine(_attackCoroutine);&#10;            _isAttacking = false;&#10;            _canAttack = true;&#10;        }&#10;        &#10;        SetHealthActual(GetHealthActual() - dmg);&#10;        &#10;        if (GetHealthActual() &lt;= 0f)&#10;            Die();&#10;        else&#10;        {&#10;            _state = CharacterState.Hurt;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_hitFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_hitBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;            _rb.linearVelocity = Vector2.zero;&#10;            StartCoroutine(Recover());&#10;        }&#10;    }&#10;&#10;    //Tiempo que el enemy tarda en recuperarse del golpe&#10;    private IEnumerator Recover()&#10;    {&#10;        yield return new WaitForSeconds(0.4f);&#10;            _state = CharacterState.Idle;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;    }&#10;&#10;    //El enemy muere&#10;    public override void Die()&#10;    {&#10;        _isDead = true;&#10;        _state = CharacterState.Die;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_deathFrontAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_deathBackAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;        }&#10;        Destroy(gameObject, 2f);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con dirección, velocidad y daño&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage, gameObject.layer);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con dirección, velocidad y daño&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage, gameObject.layer);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>