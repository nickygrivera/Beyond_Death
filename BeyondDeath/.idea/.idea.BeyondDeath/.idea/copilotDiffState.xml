<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/EnemyStatic.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/EnemyStatic.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;[RequireComponent(typeof(Rigidbody2D), typeof(Collider2D))]&#10;public class EnemyStatic : Character&#10;{&#10;    [SerializeField] private GameObject player;&#10;    [SerializeField] private float speed = 3f;&#10;    [SerializeField] private Animator anim;&#10;    [SerializeField] private SpriteRenderer sprite;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;    [SerializeField] private float projectileSpeed = 8f;&#10;    [SerializeField] private float attackRange = 4f;&#10;&#10;    private enum FacingDirection { Left, Right, Up, Down, UpLeft, UpRight, DownLeft, DownRight }&#10;    private FacingDirection _facingDirection;&#10;    private CharacterState _state;&#10;    &#10;    private Rigidbody2D _rb;&#10;    private Coroutine _attackCoroutine;&#10;    &#10;    private bool _isAttacking;&#10;    private bool _canAttack = true;&#10;    &#10;    //nombre EXACTOS de los estados&#10;    //Estados de izquierda y derecha&#10;    private readonly int _idleAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle&quot;);&#10;    private readonly int _walkAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk&quot;);&#10;    private readonly int _attackAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack&quot;);&#10;    private readonly int _hitAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit&quot;);&#10;    private readonly int _deathAnimState = Animator.StringToHash(&quot;EnemyDistance_Death&quot;);&#10;    &#10;    //Estados de front y back (w y s)&#10;    private readonly int _idleFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_Front&quot;);&#10;    private readonly int _idleBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_Back&quot;);&#10;    private readonly int _idleUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_UpRight&quot;);&#10;    private readonly int _idleDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_DownRight&quot;);&#10;    &#10;    private readonly int _walkFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_Front&quot;);&#10;    private readonly int _walkBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_Back&quot;);&#10;    private readonly int _walkUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_UpRight&quot;);&#10;    private readonly int _walkDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_DownRight&quot;);&#10;    &#10;    private readonly int _attackFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_Front&quot;);&#10;    private readonly int _attackBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_Back&quot;);&#10;    private readonly int _attackUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_UpRight&quot;);&#10;    private readonly int _attackDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_DownRight&quot;);&#10;    &#10;    private readonly int _deathFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_Front&quot;);&#10;    private readonly int _deathBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_Back&quot;);&#10;    private readonly int _deathUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_UpRight&quot;);&#10;    private readonly int _deathDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_DownRight&quot;);&#10;    &#10;    private readonly int _hitFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_Front&quot;);&#10;    private readonly int _hitBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_Back&quot;);&#10;    private readonly int _hitUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_UpRight&quot;);&#10;    private readonly int _hitDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_DownRight&quot;);&#10;    &#10;    &#10;    //Inicializar enemy&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        if(anim == null) anim = GetComponent&lt;Animator&gt;();&#10;        if(sprite == null) sprite = GetComponent&lt;SpriteRenderer&gt;();&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        SetHealthMax(100f);&#10;        SetDamage(17f);&#10;        _state = CharacterState.Idle;&#10;    }&#10;&#10;    //Calcular posicion hacia el player y moverse hasta el&#10;    private void Update()&#10;    {&#10;        if(GetHasDied() || player == null) return;&#10;        if (!_isAttacking)&#10;            UpdateRotation();&#10;&#10;        float distance = Vector2.Distance(transform.position, player.transform.position);&#10;        // Atacar al player si está en rango&#10;        if (distance &lt;= attackRange)&#10;        {&#10;            _rb.linearVelocity = Vector2.zero;&#10;            if (_canAttack &amp;&amp; !_isAttacking)&#10;                Attack();&#10;        }&#10;    }&#10;    &#10;    //Rotar enemy en base a la direccion en la que esta el player&#10;    private void UpdateRotation()&#10;         {&#10;             Vector2 direction = (player.transform.position - transform.position).normalized;&#10;             float absX = Mathf.Abs(direction.x);&#10;             float absY = Mathf.Abs(direction.y);&#10;            &#10;             //Diagonales&#10;             if (absX &gt; 0.5f &amp;&amp; absY &gt; 0.5f)&#10;             {&#10;                 if (direction.x &gt; 0 &amp;&amp; direction.y &gt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.UpRight;&#10;                     sprite.flipX = false;&#10;                     anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;                 }&#10;                 else if (direction.x &lt; 0 &amp;&amp; direction.y &gt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.UpLeft;&#10;                     sprite.flipX = true;&#10;                     anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;                 }&#10;                 else if (direction.x &gt; 0 &amp;&amp; direction.y &lt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.DownRight;&#10;                     sprite.flipX = false;&#10;                     anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;                 }&#10;                 else if (direction.x &lt; 0 &amp;&amp; direction.y &lt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.DownLeft;&#10;                     sprite.flipX = true;&#10;                     anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;                 }&#10;             //Horizontales&#10;             } else if (absX &gt; absY)&#10;             {&#10;                 _facingDirection = direction.x &lt; 0 ? FacingDirection.Left : FacingDirection.Right;&#10;                 sprite.flipX = _facingDirection == FacingDirection.Left;&#10;                 anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;             }&#10;             //verticales&#10;             else&#10;             {&#10;                 _facingDirection = direction.y &gt; 0 ? FacingDirection.Up : FacingDirection.Down;&#10;                 anim.CrossFadeInFixedTime(_facingDirection == FacingDirection.Up&#10;                     ? _walkFrontAnimState : _walkBackAnimState, 0.1f);&#10;             }&#10;         }&#10;    &#10;    //Atacar al player&#10;    public override void Attack()&#10;    {&#10;        if(_attackCoroutine != null)&#10;            StopCoroutine(_attackCoroutine);&#10;        _attackCoroutine = StartCoroutine(AttackRoutine());&#10;    }&#10;&#10;    private IEnumerator AttackRoutine()&#10;    {&#10;        _isAttacking = true;&#10;        _canAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        _state = CharacterState.Attack;&#10;        const float range = 0.7f;&#10;        Vector2 shootDirection = (player.transform.position - transform.position).normalized;&#10;        Vector3 spawnPosition = transform.position + (Vector3)(shootDirection * range);&#10;&#10;        // Animación según dirección&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_attackFrontAnimState, 0f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_attackBackAnimState, 0f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                break;&#10;        }&#10;&#10;        yield return new WaitForSeconds(0.15f); //Delay para permitir la animación antes del disparo&#10;&#10;        // Instanciar proyectil&#10;        if (projectilePrefab != null)&#10;        {&#10;            GameObject proj = Instantiate(projectilePrefab, spawnPosition, Quaternion.identity);&#10;            Projectile projectileScript = proj.GetComponent&lt;Projectile&gt;();&#10;            if (projectileScript != null)&#10;            {&#10;                projectileScript.Init(shootDirection, projectileSpeed, GetDamage());&#10;            }&#10;            else&#10;            {&#10;                Rigidbody2D projRb = proj.GetComponent&lt;Rigidbody2D&gt;();&#10;                if (projRb != null)&#10;                    projRb.velocity = shootDirection * projectileSpeed;&#10;            }&#10;        }&#10;&#10;        // Fin de animación de ataque&#10;        yield return new WaitForSeconds(GetAttackCooldown());&#10;        _isAttacking = false;&#10;        _canAttack = true;&#10;        _attackCoroutine = null;&#10;&#10;        // Animación de idle según dirección&#10;        _state = CharacterState.Idle;&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                break;&#10;        }&#10;    }&#10;&#10;    //Recibir danio si el player le ataca&#10;    public override void TakeDamage(float dmg)&#10;    {&#10;        if (GetHasDied())&#10;            return;&#10;&#10;        if (_isAttacking)&#10;        {&#10;            StopCoroutine(_attackCoroutine);&#10;            _isAttacking = false;&#10;            _canAttack = true;&#10;        }&#10;        &#10;        SetHealthActual(GetHealthActual() - dmg);&#10;        Debug.Log(&quot;Vida enemy: &quot;+ GetHealthActual());&#10;        &#10;        if (GetHealthActual() &lt;= 0f)&#10;            Die();&#10;        else&#10;        {&#10;            _state = CharacterState.Hurt;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_hitFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_hitBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;            _rb.linearVelocity = Vector2.zero;&#10;            StartCoroutine(Recover());&#10;        }&#10;    }&#10;&#10;    //Tiempo que el enemy tarda en recuperarse del golpe&#10;    private IEnumerator Recover()&#10;    {&#10;        yield return new WaitForSeconds(0.4f);&#10;            _state = CharacterState.Idle;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;    }&#10;&#10;    //El enemy muere&#10;    public override void Die()&#10;    {&#10;        SetHasDied(true);&#10;        _state = CharacterState.Die;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_deathFrontAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_deathBackAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;        }&#10;        Debug.Log(&quot;Enemy Distance muerto&quot;);&#10;        Destroy(gameObject, 2f);    //Tiempo de espera de 2 segundos antes de que se destruya el gameobject&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;[RequireComponent(typeof(Rigidbody2D), typeof(Collider2D))]&#10;public class EnemyStatic : Character&#10;{&#10;    [SerializeField] private GameObject player;&#10;    [SerializeField] private float speed = 3f;&#10;    [SerializeField] private Animator anim;&#10;    [SerializeField] private SpriteRenderer sprite;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;    [SerializeField] private float projectileSpeed = 8f;&#10;    [SerializeField] private float attackRange = 4f;&#10;&#10;    private enum FacingDirection { Left, Right, Up, Down, UpLeft, UpRight, DownLeft, DownRight }&#10;    private FacingDirection _facingDirection;&#10;    private CharacterState _state;&#10;    &#10;    private Rigidbody2D _rb;&#10;    private Coroutine _attackCoroutine;&#10;    &#10;    private bool _isAttacking;&#10;    private bool _canAttack = true;&#10;    &#10;    //nombre EXACTOS de los estados&#10;    //Estados de izquierda y derecha&#10;    private readonly int _idleAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle&quot;);&#10;    private readonly int _walkAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk&quot;);&#10;    private readonly int _attackAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack&quot;);&#10;    private readonly int _hitAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit&quot;);&#10;    private readonly int _deathAnimState = Animator.StringToHash(&quot;EnemyDistance_Death&quot;);&#10;    &#10;    //Estados de front y back (w y s)&#10;    private readonly int _idleFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_Front&quot;);&#10;    private readonly int _idleBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_Back&quot;);&#10;    private readonly int _idleUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_UpRight&quot;);&#10;    private readonly int _idleDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Idle_DownRight&quot;);&#10;    &#10;    private readonly int _walkFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_Front&quot;);&#10;    private readonly int _walkBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_Back&quot;);&#10;    private readonly int _walkUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_UpRight&quot;);&#10;    private readonly int _walkDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Walk_DownRight&quot;);&#10;    &#10;    private readonly int _attackFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_Front&quot;);&#10;    private readonly int _attackBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_Back&quot;);&#10;    private readonly int _attackUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_UpRight&quot;);&#10;    private readonly int _attackDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Attack_DownRight&quot;);&#10;    &#10;    private readonly int _deathFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_Front&quot;);&#10;    private readonly int _deathBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_Back&quot;);&#10;    private readonly int _deathUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_UpRight&quot;);&#10;    private readonly int _deathDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Death_DownRight&quot;);&#10;    &#10;    private readonly int _hitFrontAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_Front&quot;);&#10;    private readonly int _hitBackAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_Back&quot;);&#10;    private readonly int _hitUpRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_UpRight&quot;);&#10;    private readonly int _hitDownRightAnimState = Animator.StringToHash(&quot;EnemyDistance_Hit_DownRight&quot;);&#10;    &#10;    &#10;    //Inicializar enemy&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        if(anim == null) anim = GetComponent&lt;Animator&gt;();&#10;        if(sprite == null) sprite = GetComponent&lt;SpriteRenderer&gt;();&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        SetHealthMax(100f);&#10;        SetDamage(17f);&#10;        _state = CharacterState.Idle;&#10;    }&#10;&#10;    //Calcular posicion hacia el player y moverse hasta el&#10;    private void Update()&#10;    {&#10;        if(GetHasDied() || player == null) return;&#10;        if (!_isAttacking)&#10;            UpdateRotation();&#10;&#10;        float distance = Vector2.Distance(transform.position, player.transform.position);&#10;        // Atacar al player si está en rango&#10;        if (distance &lt;= attackRange)&#10;        {&#10;            _rb.linearVelocity = Vector2.zero;&#10;            if (_canAttack &amp;&amp; !_isAttacking)&#10;                Attack();&#10;        }&#10;    }&#10;    &#10;    //Rotar enemy en base a la direccion en la que esta el player&#10;    private void UpdateRotation()&#10;         {&#10;             Vector2 direction = (player.transform.position - transform.position).normalized;&#10;             float absX = Mathf.Abs(direction.x);&#10;             float absY = Mathf.Abs(direction.y);&#10;            &#10;             //Diagonales&#10;             if (absX &gt; 0.5f &amp;&amp; absY &gt; 0.5f)&#10;             {&#10;                 if (direction.x &gt; 0 &amp;&amp; direction.y &gt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.UpRight;&#10;                     sprite.flipX = false;&#10;                     anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;                 }&#10;                 else if (direction.x &lt; 0 &amp;&amp; direction.y &gt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.UpLeft;&#10;                     sprite.flipX = true;&#10;                     anim.CrossFadeInFixedTime(_walkUpRightAnimState, 0.1f);&#10;                 }&#10;                 else if (direction.x &gt; 0 &amp;&amp; direction.y &lt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.DownRight;&#10;                     sprite.flipX = false;&#10;                     anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;                 }&#10;                 else if (direction.x &lt; 0 &amp;&amp; direction.y &lt; 0)&#10;                 {&#10;                     _facingDirection = FacingDirection.DownLeft;&#10;                     sprite.flipX = true;&#10;                     anim.CrossFadeInFixedTime(_walkDownRightAnimState, 0.1f);&#10;                 }&#10;             //Horizontales&#10;             } else if (absX &gt; absY)&#10;             {&#10;                 _facingDirection = direction.x &lt; 0 ? FacingDirection.Left : FacingDirection.Right;&#10;                 sprite.flipX = _facingDirection == FacingDirection.Left;&#10;                 anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;             }&#10;             //verticales&#10;             else&#10;             {&#10;                 _facingDirection = direction.y &gt; 0 ? FacingDirection.Up : FacingDirection.Down;&#10;                 anim.CrossFadeInFixedTime(_facingDirection == FacingDirection.Up&#10;                     ? _walkFrontAnimState : _walkBackAnimState, 0.1f);&#10;             }&#10;         }&#10;    &#10;    //Atacar al player&#10;    public override void Attack()&#10;    {&#10;        if(_attackCoroutine != null)&#10;            StopCoroutine(_attackCoroutine);&#10;        _attackCoroutine = StartCoroutine(AttackRoutine());&#10;    }&#10;&#10;    private IEnumerator AttackRoutine()&#10;    {&#10;        _isAttacking = true;&#10;        _canAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        _state = CharacterState.Attack;&#10;        const float range = 0.7f;&#10;        Vector2 shootDirection = (player.transform.position - transform.position).normalized;&#10;        Vector3 spawnPosition = transform.position + (Vector3)(shootDirection * range);&#10;&#10;        // Animación según dirección&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackAnimState, 0f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_attackFrontAnimState, 0f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_attackBackAnimState, 0f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackUpRightAnimState, 0f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_attackDownRightAnimState, 0f);&#10;                break;&#10;        }&#10;&#10;        yield return new WaitForSeconds(0.15f); //Delay para permitir la animación antes del disparo&#10;&#10;        // Instanciar proyectil&#10;        if (projectilePrefab != null)&#10;        {&#10;            GameObject proj = Instantiate(projectilePrefab, spawnPosition, Quaternion.identity);&#10;            Projectile projectileScript = proj.GetComponent&lt;Projectile&gt;();&#10;            if (projectileScript != null)&#10;            {&#10;                projectileScript.Init(shootDirection, projectileSpeed, GetDamage());&#10;            }&#10;            else&#10;            {&#10;                Rigidbody2D projRb = proj.GetComponent&lt;Rigidbody2D&gt;();&#10;                if (projRb != null)&#10;                    projRb.velocity = shootDirection * projectileSpeed;&#10;            }&#10;        }&#10;&#10;        // Fin de animación de ataque&#10;        yield return new WaitForSeconds(GetAttackCooldown());&#10;        _isAttacking = false;&#10;        _canAttack = true;&#10;        _attackCoroutine = null;&#10;&#10;        // Animación de idle según dirección&#10;        _state = CharacterState.Idle;&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                break;&#10;        }&#10;    }&#10;&#10;    //Recibir danio si el player le ataca&#10;    public override void TakeDamage(float dmg)&#10;    {&#10;        if (GetHasDied())&#10;            return;&#10;&#10;        if (_isAttacking)&#10;        {&#10;            StopCoroutine(_attackCoroutine);&#10;            _isAttacking = false;&#10;            _canAttack = true;&#10;        }&#10;        &#10;        SetHealthActual(GetHealthActual() - dmg);&#10;        Debug.Log(&quot;Vida enemy: &quot;+ GetHealthActual());&#10;        &#10;        if (GetHealthActual() &lt;= 0f)&#10;            Die();&#10;        else&#10;        {&#10;            _state = CharacterState.Hurt;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_hitFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_hitBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_hitDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;            _rb.linearVelocity = Vector2.zero;&#10;            StartCoroutine(Recover());&#10;        }&#10;    }&#10;&#10;    //Tiempo que el enemy tarda en recuperarse del golpe&#10;    private IEnumerator Recover()&#10;    {&#10;        yield return new WaitForSeconds(0.4f);&#10;            _state = CharacterState.Idle;&#10;            switch (_facingDirection)&#10;            {&#10;                case FacingDirection.Left:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Right:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Up:&#10;                    anim.CrossFadeInFixedTime(_idleFrontAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.Down:&#10;                    anim.CrossFadeInFixedTime(_idleBackAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.UpRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleUpRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownLeft:&#10;                    sprite.flipX = true;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;                case FacingDirection.DownRight:&#10;                    sprite.flipX = false;&#10;                    anim.CrossFadeInFixedTime(_idleDownRightAnimState, 0.1f);&#10;                    break;&#10;            }&#10;    }&#10;&#10;    //El enemy muere&#10;    public override void Die()&#10;    {&#10;        SetHasDied(true);&#10;        _state = CharacterState.Die;&#10;        _rb.linearVelocity = Vector2.zero;&#10;        switch (_facingDirection)&#10;        {&#10;            case FacingDirection.Left:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Right:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Up:&#10;                anim.CrossFadeInFixedTime(_deathFrontAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.Down:&#10;                anim.CrossFadeInFixedTime(_deathBackAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.UpRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathUpRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownLeft:&#10;                sprite.flipX = true;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;            case FacingDirection.DownRight:&#10;                sprite.flipX = false;&#10;                anim.CrossFadeInFixedTime(_deathDownRightAnimState, 0.1f);&#10;                break;&#10;        }&#10;        Debug.Log(&quot;Enemy Distance muerto&quot;);&#10;        Destroy(gameObject, 2f);    //Tiempo de espera de 2 segundos antes de que se destruya el gameobject&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>