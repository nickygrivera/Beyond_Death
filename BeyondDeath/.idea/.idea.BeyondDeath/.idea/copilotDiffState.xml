<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con direcci칩n, velocidad y da침o&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage, gameObject.layer);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con direcci칩n, velocidad y da침o&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage, gameObject.layer);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>