<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; * En el inspector y en las animaciones de prueba se cambian por clips de animacion&#10; * Hay 3 tipos de clips de animaciones:&#10; *&#10; * Es decir que cada accion como por ejemplo idle puede estar en der(es la misma animacion para izquierda  pero con Flip , &#10; * ya lo hace el codigo solo),front y back.&#10; *&#10; * Al impotar las animaciones , se deberán cambiar por las que aparece en la zona de Animator.StringtoHash&#10; * por ejemplo &quot;Player_Idle&quot; , siguiendo esa estructura para que el codigo funcione&#10; * Estan implementado todas las animaciones segun la direccion del raton y tambien segun la tecla.&#10; * &#10; * En player (root) ,apartado de Animator se le pasa el de playerAesthetics&#10; * En escena cambiar las Anchor para que coincidan con la del player&#10; * En la zona de Animator no hay transiciones todo lo hace por crossfadeIn&#10; * */&#10;&#10;&#10;&#10;[RequireComponent(typeof(Rigidbody2D), typeof(CapsuleCollider2D))]&#10;public class Player : Character&#10;{&#10;&#10;    [SerializeField] private float moveSpeed = 5f;&#10;&#10;    [SerializeField] private Animator anim;//_anim arrastrar aqui el animator de playerAesthetics&#10;    [SerializeField] private SpriteRenderer spriteRenderer;//para que rote visualmente al caminar (ARREGLO DEL SALTO)&#10;&#10;&#10;    [SerializeField] private float dashSpeed = 16f;&#10;    [SerializeField] private float dashCooldown = 0.5f;&#10;&#10;&#10;    //nombre EXACTOS de los estados&#10;    //Estados de izquierda y derecha&#10;    private readonly int _idleAnimState = Animator.StringToHash(&quot;Player_Idle&quot;);&#10;    private readonly int _walkAnimState = Animator.StringToHash(&quot;Player_Walk&quot;);&#10;    private readonly int _attack1AnimState = Animator.StringToHash(&quot;Player_Attack1&quot;);&#10;    private readonly int _attack2AnimState = Animator.StringToHash(&quot;Player_Attack2&quot;);&#10;    private readonly int _hitAnimState = Animator.StringToHash(&quot;Player_Hit&quot;);&#10;    private readonly int _deathAnimState = Animator.StringToHash(&quot;Player_Death&quot;);&#10;    private readonly int _dashAnimState = Animator.StringToHash(&quot;Player_Dash&quot;);&#10;&#10;&#10;    //Estados de front y back (w y s)&#10;    private readonly int _idleFrontAnimState = Animator.StringToHash(&quot;Player_Idle_Front&quot;);&#10;    private readonly int _idleBackAnimState = Animator.StringToHash(&quot;Player_Idle_Back&quot;);&#10;&#10;    private readonly int _walkFrontAnimState = Animator.StringToHash(&quot;Player_Walk_Front&quot;);&#10;    private readonly int _walkBackAnimState = Animator.StringToHash(&quot;Player_Walk_Back&quot;);&#10;&#10;    private readonly int _attack1FrontAnimState = Animator.StringToHash(&quot;Player_Attack1_Front&quot;);&#10;    private readonly int _attack1BackAnimState = Animator.StringToHash(&quot;Player_Attack1_Back&quot;);&#10;&#10;    private readonly int _attack2FrontAnimState = Animator.StringToHash(&quot;Player_Attack2_Front&quot;);&#10;    private readonly int _attack2BackAnimState = Animator.StringToHash(&quot;Player_Attack2_Back&quot;);&#10;&#10;    private readonly int _dashFrontAnimState = Animator.StringToHash(&quot;Player_Dash_Front&quot;);&#10;    private readonly int _dashBackAnimState = Animator.StringToHash(&quot;Player_Dash_Back&quot;);&#10;&#10;    private readonly int _deathFrontAnimState = Animator.StringToHash(&quot;Player_Death_Front&quot;);&#10;    private readonly int _deathBackAnimState = Animator.StringToHash(&quot;Player_Death_Back&quot;);&#10;&#10;    private readonly int _hitFrontAnimState = Animator.StringToHash(&quot;Player_Hit_Front&quot;);&#10;    private readonly int _hitBackAnimState = Animator.StringToHash(&quot;Player_Hit_Back&quot;);&#10;&#10;    //variables del codigo&#10;    private Rigidbody2D _rb;&#10;    private Vector2 _movement;//direccion del input&#10;    private Vector2 _animDir = Vector2.right;//direccion del raton&#10;    private int _currentLocomotionHash = -1;//recuerda el clip de animacion que usa para poder cambiar&#10;    private Vector2 _rawMove;//mira la direccion y prioriza las 4 dir&#10;&#10;    private bool _isMoving;&#10;&#10;    private bool _isAttack = true;&#10;    private bool _isDashing;&#10;    private bool _canDash = true;&#10;&#10;    private CharacterState _state;&#10;&#10;&#10;    //GETTERS PARA LECTURA DE DATOS&#10;    public float CurrentHealth&#10;    {&#10;        get&#10;        {&#10;            return GetHealthActual();&#10;        }&#10;    }&#10;&#10;    public float MaxHealth&#10;    {&#10;        get&#10;        {&#10;            return GetHealthMax();&#10;        }&#10;    }&#10;&#10;    public float DashCooldown&#10;    {&#10;        get&#10;        {&#10;            return dashCooldown;&#10;        }&#10;    }&#10;&#10;    public bool CanDash&#10;    {&#10;        get&#10;        {&#10;            return _canDash;&#10;        }&#10;    }&#10;&#10;    public bool IsDashing&#10;    {&#10;        get&#10;        {&#10;            return _isDashing;&#10;        }&#10;    }&#10;&#10;    public bool IsAttacking&#10;    {&#10;        get&#10;        {&#10;            return _state == CharacterState.Attack;&#10;        }&#10;    }&#10;&#10;    public bool IsDead&#10;    {&#10;        get&#10;        {&#10;            return _state == CharacterState.Die;&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        anim = GetComponentInChildren&lt;Animator&gt;();&#10;&#10;        _rb.gravityScale = 0f;&#10;        _rb.freezeRotation = true;&#10;&#10;        //inicializamos la vida y el daño&#10;        SetHealthMax(GetHealthMax());&#10;        SetDamage(GetDamage());&#10;&#10;        _state = CharacterState.Idle;&#10;&#10;        //fallback&#10;        if (spriteRenderer == null)&#10;        {&#10;            spriteRenderer = GetComponentInChildren&lt;SpriteRenderer&gt;(true);&#10;        }&#10;&#10;    }&#10;&#10;&#10;    //codigo de la plantilla del character (samurai)&#10;    private void OnEnable()//suscripciones&#10;    {&#10;        if (InputManager.Instance != null)&#10;        {&#10;            InputManager.Instance.AttackPerformed += Attack1;&#10;            InputManager.Instance.AttackDistancePerformed += Attack2;&#10;            InputManager.Instance.DashPerformed += OnDashInput;&#10;        }&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (InputManager.Instance != null)&#10;        {&#10;            InputManager.Instance.AttackPerformed -= Attack1;&#10;            InputManager.Instance.AttackDistancePerformed -= Attack2;&#10;            InputManager.Instance.DashPerformed -= OnDashInput;&#10;        }&#10;    }&#10;&#10;&#10;    private void Update()//primero lee la entrada de teclado y luego la direccion del raton&#10;    {&#10;        if (_state == CharacterState.Hurt || _state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;&#10;        /* //8 DIRECCIONES&#10;         * &#10;        //lectura de teclas y normaliza para evitar lo de la diagonal&#10;        _movement = InputManager.Instance != null ? InputManager.Instance.GetMovement() : Vector2.zero;&#10;        if (_movement.sqrMagnitude &gt; 1f)&#10;        {&#10;            _movement.Normalize();//corrige la diagonal&#10;        }*/&#10;&#10;&#10;        if (InputManager.Instance != null)&#10;        {&#10;            _rawMove = InputManager.Instance.GetMovement();&#10;        }&#10;        else&#10;        {&#10;            _rawMove = Vector2.zero;&#10;        }&#10;&#10;        //mira el eje que mas predomina para los 4 card&#10;        if (Mathf.Abs(_rawMove.x) &gt; Mathf.Abs(_rawMove.y))&#10;        {&#10;            _rawMove.y = 0f;//horizontal&#10;        }&#10;        else if (Mathf.Abs(_rawMove.y) &gt; 0f)&#10;        {&#10;            _rawMove.x = 0f;//vertical&#10;        }&#10;        &#10;        _movement = _rawMove.normalized;//normaliza en ese eje&#10;&#10;&#10;&#10;        //dir del ratón para decidir front o back&#10;        if (InputManager.Instance != null)&#10;        {&#10;            Vector3 mouseWorld = InputManager.Instance.GetPointerWorldPosition();&#10;&#10;            Vector2 dir = mouseWorld - transform.position;&#10;            if (dir.sqrMagnitude &gt; 0.0001f)&#10;            {&#10;                _animDir = dir.normalized;&#10;            }&#10;        }&#10;&#10;&#10;        //cambio flip visualmente no por player(root) , depende de si hay movimiento o no&#10;        if (_state != CharacterState.Attack &amp;&amp; _state != CharacterState.Dash)&#10;        {&#10;            float x;&#10;            _isMoving = !IsNearlyZero(_movement);&#10;&#10;            if (_isMoving)&#10;            {&#10;                //flip depende de la dirección de movimiento(en movimiento)&#10;                x = _movement.x;&#10;            }&#10;            else&#10;            {&#10;                //flip depende del ratón ( en idle)&#10;                x = _animDir.x;&#10;            }&#10;&#10;            if (x &lt; -0.01f)&#10;            {&#10;                spriteRenderer.flipX = true;//izq&#10;            }&#10;            else if (x &gt; 0.01f)&#10;            {&#10;                spriteRenderer.flipX = false;//der&#10;            }&#10;        }&#10;&#10;        //elige la direccion y luego reproduce el clip de ese lado &#10;&#10;        if (_state == CharacterState.Idle || _state == CharacterState.Walk)&#10;        {&#10;            _isMoving = !IsNearlyZero(_movement);&#10;&#10;            if (!_isMoving)&#10;            {&#10;                //idle se decide por raton&#10;                int idleTarget;&#10;                bool aimVertical = IsVerticalDominant(_animDir);&#10;                if (aimVertical)&#10;                {&#10;                    idleTarget = (_animDir.y &gt;= 0f) ? _idleBackAnimState : _idleFrontAnimState;&#10;                }&#10;                else&#10;                {&#10;&#10;                    idleTarget = _idleAnimState; //flipX a la izq&#10;                }&#10;&#10;                //si no esta en idle&#10;                if (_state != CharacterState.Idle)&#10;                {&#10;                    _state = CharacterState.Idle;&#10;                    CrossFadeSafe(idleTarget, _idleAnimState, 0.2f);&#10;                    _currentLocomotionHash = idleTarget;&#10;                }&#10;                else&#10;                {&#10;                    // en idle mira la dir de  raton(arriba o abajo)&#10;                    if (_currentLocomotionHash != idleTarget)&#10;                    {&#10;                        CrossFadeSafe(idleTarget, _idleAnimState, 0.2f);&#10;                        _currentLocomotionHash = idleTarget;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                //walk se decide por movimiento del teclado&#10;                int walkTarget;&#10;                bool moveVertical = IsVerticalDominant(_movement);&#10;                if (moveVertical)&#10;                {&#10;                    walkTarget = (_movement.y &gt;= 0f) ? _walkBackAnimState : _walkFrontAnimState;&#10;                }&#10;                else&#10;                {&#10;                    //&#10;                    walkTarget = _walkAnimState; //flipXva a la izq&#10;                }&#10;&#10;                if (_state != CharacterState.Walk)&#10;                {&#10;                    _state = CharacterState.Walk;&#10;                    CrossFadeSafe(walkTarget, _walkAnimState, 0.2f);&#10;                    _currentLocomotionHash = walkTarget;&#10;                }&#10;                else&#10;                {&#10;                    // en walk, cambia de vertical a horizontal o alrevés&#10;                    if (_currentLocomotionHash != walkTarget)&#10;                    {&#10;                        CrossFadeSafe(walkTarget, _walkAnimState, 0.1f);&#10;                        _currentLocomotionHash = walkTarget;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;&#10;    private void FixedUpdate()&#10;    {&#10;        if (_state == CharacterState.Hurt || _state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;        if (_state == CharacterState.Attack)&#10;        {&#10;            _rb.linearVelocity = Vector2.zero;//durante el ataque no se mueve el player&#10;        }&#10;        else if (!_isDashing)&#10;        {&#10;            _rb.linearVelocity = _movement * moveSpeed;&#10;        }&#10;&#10;    }&#10;&#10;    //DASH&#10;    //En la animacion de prueba del dash hace un frontflip&#10;    //Dash del player&#10;    private void OnDashInput()&#10;    {&#10;        if (!_canDash || _state == CharacterState.Attack || _state == CharacterState.Hurt || _state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;&#10;        StartCoroutine(Dash());&#10;    }&#10;&#10;&#10;&#10;    private IEnumerator Dash()&#10;    {&#10;        _isDashing = true;&#10;        _canDash = false;&#10;&#10;        //anim del dash segun dir&#10;        _state = CharacterState.Dash;&#10;&#10;        bool verticalDominant = Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x);&#10;        int dashTarget;&#10;&#10;        if (verticalDominant)&#10;        {&#10;            dashTarget = (_animDir.y &gt;= 0f) ? _dashBackAnimState : _dashFrontAnimState;&#10;        }&#10;        else&#10;        {&#10;            dashTarget = _dashAnimState;&#10;        }&#10;&#10;        CrossFadeSafe(dashTarget, _dashAnimState, 0f);&#10;&#10;&#10;        _rb.linearVelocity = _movement * dashSpeed;//dash&#10;        yield return new WaitForSeconds(dashCooldown);&#10;        _isDashing = false;&#10;&#10;        //vuelve a idle o walk segun teclado&#10;        if (_movement == Vector2.zero)&#10;        {&#10;            _state = CharacterState.Idle;&#10;            anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;            _rb.linearVelocity = Vector2.zero;&#10;        }&#10;        else&#10;        {&#10;            _state = CharacterState.Walk;&#10;            anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;            _rb.linearVelocity = _movement * moveSpeed;&#10;        }&#10;&#10;&#10;        _canDash = true;&#10;    }&#10;&#10;&#10;    //ATTACKS&#10;&#10;    public override void Attack()&#10;    {&#10;        Attack1();&#10;    }&#10;&#10;&#10;    private void Attack1()//ataque meele&#10;    {&#10;        if (!_isAttack || _state == CharacterState.Attack || _state == CharacterState.Die) return;&#10;&#10;        _state = CharacterState.Attack;&#10;        _isAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;&#10;        //elige animacion segun dir del raton&#10;        bool verticalDominant = false;&#10;        if (Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x))&#10;        {&#10;            verticalDominant = true;&#10;        }&#10;&#10;        int atk1Target;&#10;&#10;        if (verticalDominant)&#10;        {&#10;            atk1Target = (_animDir.y &gt;= 0f) ? _attack1BackAnimState : _attack1FrontAnimState;&#10;&#10;        }&#10;        else&#10;        {&#10;            atk1Target = _attack1AnimState;////&#10;        }&#10;&#10;        CrossFadeSafe(atk1Target, _attack1AnimState, 0f);&#10;&#10;        //hitbox melee&#10;        if (hitAnchor)&#10;        {&#10;            Vector2 forward;&#10;&#10;            if (_animDir.sqrMagnitude &gt; 0.0001f)&#10;            {&#10;                forward = _animDir;&#10;            }&#10;            else&#10;            {&#10;                if (spriteRenderer.flipX)&#10;                {&#10;                    forward = Vector2.left;&#10;                }&#10;                else&#10;                {&#10;                    forward = Vector2.right;&#10;                }&#10;                  &#10;            }&#10;&#10;            float forwardOffset = 0.4f;&#10;&#10;            Vector2 center = (Vector2)hitAnchor.position + forward * forwardOffset;&#10;            float angleDeg = Mathf.Atan2(forward.y, forward.x) * Mathf.Rad2Deg;&#10;&#10;            Collider2D[] results = Physics2D.OverlapBoxAll(center, hitSize, angleDeg);&#10;&#10;            foreach (var col in results)&#10;            {&#10;                if (col.CompareTag(&quot;Enemy&quot;))&#10;                {&#10;                    //mira si es un character&#10;                    Character enemyChar = col.GetComponentInParent&lt;Character&gt;();&#10;&#10;                    if (enemyChar != null)&#10;                    {&#10;                        //enemigo recibe danio&#10;                        enemyChar.TakeDamage(GetDamage());&#10;&#10;                    }&#10;                }&#10;            }&#10;            &#10;            StartCoroutine(WaitForAnimationToEnd(atk1Target));&#10;        }&#10;    }&#10;&#10;    //Ataque a distancia&#10;    private void Attack2()&#10;    {&#10;        if (!_isAttack || _state == CharacterState.Attack || _state == CharacterState.Die) return;&#10;&#10;        _state = CharacterState.Attack;&#10;        _isAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;&#10;        bool verticalDominant = Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x);&#10;        int atk2Target;&#10;&#10;        if (verticalDominant)&#10;        {&#10;            if (_animDir.y &gt;= 0f)&#10;            {&#10;                atk2Target = _attack2BackAnimState;&#10;            }&#10;            else&#10;            {&#10;                atk2Target = _attack2FrontAnimState;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            atk2Target = _attack2AnimState;&#10;        }&#10;&#10;        // Calcular la dirección hacia el puntero del ratón justo antes de disparar&#10;        Vector3 mouseWorld = InputManager.Instance.GetPointerWorldPosition();&#10;        Vector2 shootDir = (mouseWorld - transform.position).sqrMagnitude &gt; 0.0001f ? (mouseWorld - transform.position).normalized : Vector2.right;&#10;        &#10;        //Llamada al spawner&#10;        ProjectileSpawner spawner = GetComponent&lt;ProjectileSpawner&gt;();&#10;        if (spawner != null)&#10;        {&#10;            spawner.SpawnProjectile(shootDir);&#10;        }&#10;        &#10;        CrossFadeSafe(atk2Target, _attack2AnimState, 0f);&#10;        StartCoroutine(WaitForAnimationToEnd(atk2Target));&#10;    }&#10;&#10;&#10;    //TAKEDAMAGE O HIT&#10;    //overrides de character&#10;    public override void TakeDamage(float dmg)&#10;    {&#10;&#10;        if (_state == CharacterState.Dash || _isDashing)&#10;        {&#10;            return;&#10;        }&#10;&#10;        if (_state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;&#10;        SetHealthActual(GetHealthActual() - dmg);&#10;&#10;        if (GetHealthActual() &lt;= 0f)&#10;        {&#10;            _state = CharacterState.Die;&#10;            _rb.linearVelocity = Vector2.zero;&#10;&#10;            bool verticalDominant = false;&#10;            if (Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x))&#10;            {&#10;                verticalDominant = true;&#10;            }&#10;&#10;            int deathTarget;&#10;&#10;            if (verticalDominant)&#10;            {&#10;                deathTarget = (_animDir.y &gt;= 0f) ? _deathBackAnimState : _deathFrontAnimState;&#10;&#10;            }&#10;            else&#10;            {&#10;                deathTarget = _deathFrontAnimState;&#10;            }&#10;&#10;            CrossFadeSafe(deathTarget, _deathAnimState, 0f);&#10;        }&#10;        else&#10;        {&#10;            _state = CharacterState.Hurt;&#10;            _isAttack = false;&#10;            _rb.linearVelocity = Vector2.zero;&#10;&#10;            //elegir front o back segun el raton&#10;            bool verticalDominant = false;&#10;            if (Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x))&#10;            {&#10;                verticalDominant = true;&#10;            }&#10;&#10;            int hitTarget; // fallback genérico&#10;&#10;            if (verticalDominant)&#10;            {&#10;                hitTarget = (_animDir.y &gt;= 0f) ? _hitBackAnimState : _hitFrontAnimState; // arriba : abajo&#10;&#10;            }&#10;            else&#10;            {&#10;                hitTarget = _hitAnimState;//horizontal&#10;            }&#10;&#10;            CrossFadeSafe(hitTarget, _hitAnimState, 0f);&#10;&#10;            //espera al hit segun fallback&#10;            StartCoroutine(WaitForAnimationToEnd(hitTarget, _hitAnimState));&#10;        }&#10;    }&#10;&#10;&#10;    //DEATH&#10;    public override void Die()&#10;    {&#10;        Debug.Log(&quot;Player muerto&quot;);&#10;        //TODO:codigo reiniciar todas las escenas si muere&#10;        //TODO:lanzar escena o UI de Game over&#10;    }&#10;&#10;    //ANIMACIONES&#10;    //espera a que acabe las animaciones (espera al fallback),para estar en idle&#10;    private IEnumerator WaitForAnimationToEnd(int preferredState, int fallbackState)&#10;    {&#10;        AnimatorStateInfo stateInfo = anim.GetCurrentAnimatorStateInfo(0);&#10;&#10;        //espera al fallback&#10;        while (stateInfo.shortNameHash != preferredState &amp;&amp; stateInfo.shortNameHash != fallbackState)&#10;        {&#10;            yield return null;&#10;&#10;            stateInfo = anim.GetCurrentAnimatorStateInfo(0);&#10;        }&#10;&#10;        //espera a normalizarla y que la animacion finalice&#10;        while (stateInfo.normalizedTime &lt; 1f)&#10;        {&#10;            yield return null;&#10;&#10;            stateInfo = anim.GetCurrentAnimatorStateInfo(0);&#10;        }&#10;        //si muere ,deja el loop y no vuelve a idle&#10;        if (_state != CharacterState.Die)&#10;        {&#10;            _state = CharacterState.Idle;&#10;&#10;            anim.CrossFadeInFixedTime(_idleAnimState, 0f);&#10;            _isAttack = true;&#10;        }&#10;        &#10;    }&#10;&#10;    //ref de 1 parametro cuando no hay fallback&#10;    private IEnumerator WaitForAnimationToEnd(int animState)&#10;    {&#10;        return WaitForAnimationToEnd(animState, animState);&#10;    }&#10;&#10;&#10;    //cambia la animacion en caso de que no haya clip, para no colapsar (lo hace en caso de que falte o falle algun clip)&#10;    private void CrossFadeSafe(int preferredStateHash, int fallbackStateHash, float fade)&#10;    {&#10;        if (anim &amp;&amp; anim.runtimeAnimatorController &amp;&amp; anim.HasState(0, preferredStateHash))&#10;        {&#10;            anim.CrossFadeInFixedTime(preferredStateHash, fade);&#10;        }&#10;&#10;        else&#10;        {&#10;            anim.CrossFadeInFixedTime(fallbackStateHash, fade);&#10;        }&#10;&#10;    }&#10;&#10;    //Helpers para la dir del raton&#10;    private bool IsNearlyZero(Vector2 v)&#10;    {&#10;        return v.sqrMagnitude &lt; 0.0001f;//comprueba si el player esta quieto o no (cerca de 0)&#10;    }&#10;&#10;    private bool IsVerticalDominant(Vector2 v)//determina si se apunta mas arriba que a la izq/der&#10;    {//para poder decidir entre las animaciones&#10;        return Mathf.Abs(v.y) &gt;= Mathf.Abs(v.x);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; * En el inspector y en las animaciones de prueba se cambian por clips de animacion&#10; * Hay 3 tipos de clips de animaciones:&#10; *&#10; * Es decir que cada accion como por ejemplo idle puede estar en der(es la misma animacion para izquierda  pero con Flip , &#10; * ya lo hace el codigo solo),front y back.&#10; *&#10; * Al impotar las animaciones , se deberán cambiar por las que aparece en la zona de Animator.StringtoHash&#10; * por ejemplo &quot;Player_Idle&quot; , siguiendo esa estructura para que el codigo funcione&#10; * Estan implementado todas las animaciones segun la direccion del raton y tambien segun la tecla.&#10; * &#10; * En player (root) ,apartado de Animator se le pasa el de playerAesthetics&#10; * En escena cambiar las Anchor para que coincidan con la del player&#10; * En la zona de Animator no hay transiciones todo lo hace por crossfadeIn&#10; * */&#10;&#10;&#10;&#10;[RequireComponent(typeof(Rigidbody2D), typeof(CapsuleCollider2D))]&#10;public class Player : Character&#10;{&#10;&#10;    [SerializeField] private float moveSpeed = 5f;&#10;&#10;    [SerializeField] private Animator anim;//_anim arrastrar aqui el animator de playerAesthetics&#10;    [SerializeField] private SpriteRenderer spriteRenderer;//para que rote visualmente al caminar (ARREGLO DEL SALTO)&#10;&#10;&#10;    [SerializeField] private float dashSpeed = 16f;&#10;    [SerializeField] private float dashCooldown = 0.5f;&#10;&#10;&#10;    //nombre EXACTOS de los estados&#10;    //Estados de izquierda y derecha&#10;    private readonly int _idleAnimState = Animator.StringToHash(&quot;Player_Idle&quot;);&#10;    private readonly int _walkAnimState = Animator.StringToHash(&quot;Player_Walk&quot;);&#10;    private readonly int _attack1AnimState = Animator.StringToHash(&quot;Player_Attack1&quot;);&#10;    private readonly int _attack2AnimState = Animator.StringToHash(&quot;Player_Attack2&quot;);&#10;    private readonly int _hitAnimState = Animator.StringToHash(&quot;Player_Hit&quot;);&#10;    private readonly int _deathAnimState = Animator.StringToHash(&quot;Player_Death&quot;);&#10;    private readonly int _dashAnimState = Animator.StringToHash(&quot;Player_Dash&quot;);&#10;&#10;&#10;    //Estados de front y back (w y s)&#10;    private readonly int _idleFrontAnimState = Animator.StringToHash(&quot;Player_Idle_Front&quot;);&#10;    private readonly int _idleBackAnimState = Animator.StringToHash(&quot;Player_Idle_Back&quot;);&#10;&#10;    private readonly int _walkFrontAnimState = Animator.StringToHash(&quot;Player_Walk_Front&quot;);&#10;    private readonly int _walkBackAnimState = Animator.StringToHash(&quot;Player_Walk_Back&quot;);&#10;&#10;    private readonly int _attack1FrontAnimState = Animator.StringToHash(&quot;Player_Attack1_Front&quot;);&#10;    private readonly int _attack1BackAnimState = Animator.StringToHash(&quot;Player_Attack1_Back&quot;);&#10;&#10;    private readonly int _attack2FrontAnimState = Animator.StringToHash(&quot;Player_Attack2_Front&quot;);&#10;    private readonly int _attack2BackAnimState = Animator.StringToHash(&quot;Player_Attack2_Back&quot;);&#10;&#10;    private readonly int _dashFrontAnimState = Animator.StringToHash(&quot;Player_Dash_Front&quot;);&#10;    private readonly int _dashBackAnimState = Animator.StringToHash(&quot;Player_Dash_Back&quot;);&#10;&#10;    private readonly int _deathFrontAnimState = Animator.StringToHash(&quot;Player_Death_Front&quot;);&#10;    private readonly int _deathBackAnimState = Animator.StringToHash(&quot;Player_Death_Back&quot;);&#10;&#10;    private readonly int _hitFrontAnimState = Animator.StringToHash(&quot;Player_Hit_Front&quot;);&#10;    private readonly int _hitBackAnimState = Animator.StringToHash(&quot;Player_Hit_Back&quot;);&#10;&#10;    //variables del codigo&#10;    private Rigidbody2D _rb;&#10;    private Vector2 _movement;//direccion del input&#10;    private Vector2 _animDir = Vector2.right;//direccion del raton&#10;    private int _currentLocomotionHash = -1;//recuerda el clip de animacion que usa para poder cambiar&#10;    private Vector2 _rawMove;//mira la direccion y prioriza las 4 dir&#10;&#10;    private bool _isMoving;&#10;&#10;    private bool _isAttack = true;&#10;    private bool _isDashing;&#10;    private bool _canDash = true;&#10;&#10;    private CharacterState _state;&#10;&#10;&#10;    //GETTERS PARA LECTURA DE DATOS&#10;    public float CurrentHealth&#10;    {&#10;        get&#10;        {&#10;            return GetHealthActual();&#10;        }&#10;    }&#10;&#10;    public float MaxHealth&#10;    {&#10;        get&#10;        {&#10;            return GetHealthMax();&#10;        }&#10;    }&#10;&#10;    public float DashCooldown&#10;    {&#10;        get&#10;        {&#10;            return dashCooldown;&#10;        }&#10;    }&#10;&#10;    public bool CanDash&#10;    {&#10;        get&#10;        {&#10;            return _canDash;&#10;        }&#10;    }&#10;&#10;    public bool IsDashing&#10;    {&#10;        get&#10;        {&#10;            return _isDashing;&#10;        }&#10;    }&#10;&#10;    public bool IsAttacking&#10;    {&#10;        get&#10;        {&#10;            return _state == CharacterState.Attack;&#10;        }&#10;    }&#10;&#10;    public bool IsDead&#10;    {&#10;        get&#10;        {&#10;            return _state == CharacterState.Die;&#10;        }&#10;    }&#10;&#10;&#10;&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        anim = GetComponentInChildren&lt;Animator&gt;();&#10;&#10;        _rb.gravityScale = 0f;&#10;        _rb.freezeRotation = true;&#10;&#10;        //inicializamos la vida y el daño&#10;        SetHealthMax(GetHealthMax());&#10;        SetDamage(GetDamage());&#10;&#10;        _state = CharacterState.Idle;&#10;&#10;        //fallback&#10;        if (spriteRenderer == null)&#10;        {&#10;            spriteRenderer = GetComponentInChildren&lt;SpriteRenderer&gt;(true);&#10;        }&#10;&#10;    }&#10;&#10;&#10;    //codigo de la plantilla del character (samurai)&#10;    private void OnEnable()//suscripciones&#10;    {&#10;        if (InputManager.Instance != null)&#10;        {&#10;            InputManager.Instance.AttackPerformed += Attack1;&#10;            InputManager.Instance.AttackDistancePerformed += Attack2;&#10;            InputManager.Instance.DashPerformed += OnDashInput;&#10;        }&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (InputManager.Instance != null)&#10;        {&#10;            InputManager.Instance.AttackPerformed -= Attack1;&#10;            InputManager.Instance.AttackDistancePerformed -= Attack2;&#10;            InputManager.Instance.DashPerformed -= OnDashInput;&#10;        }&#10;    }&#10;&#10;&#10;    private void Update()//primero lee la entrada de teclado y luego la direccion del raton&#10;    {&#10;        if (_state == CharacterState.Hurt || _state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;&#10;        /* //8 DIRECCIONES&#10;         * &#10;        //lectura de teclas y normaliza para evitar lo de la diagonal&#10;        _movement = InputManager.Instance != null ? InputManager.Instance.GetMovement() : Vector2.zero;&#10;        if (_movement.sqrMagnitude &gt; 1f)&#10;        {&#10;            _movement.Normalize();//corrige la diagonal&#10;        }*/&#10;&#10;&#10;        if (InputManager.Instance != null)&#10;        {&#10;            _rawMove = InputManager.Instance.GetMovement();&#10;        }&#10;        else&#10;        {&#10;            _rawMove = Vector2.zero;&#10;        }&#10;&#10;        //mira el eje que mas predomina para los 4 card&#10;        if (Mathf.Abs(_rawMove.x) &gt; Mathf.Abs(_rawMove.y))&#10;        {&#10;            _rawMove.y = 0f;//horizontal&#10;        }&#10;        else if (Mathf.Abs(_rawMove.y) &gt; 0f)&#10;        {&#10;            _rawMove.x = 0f;//vertical&#10;        }&#10;        &#10;        _movement = _rawMove.normalized;//normaliza en ese eje&#10;&#10;&#10;&#10;        //dir del ratón para decidir front o back&#10;        if (InputManager.Instance != null)&#10;        {&#10;            Vector3 mouseWorld = InputManager.Instance.GetPointerWorldPosition();&#10;&#10;            Vector2 dir = mouseWorld - transform.position;&#10;            if (dir.sqrMagnitude &gt; 0.0001f)&#10;            {&#10;                _animDir = dir.normalized;&#10;            }&#10;        }&#10;&#10;&#10;        //cambio flip visualmente no por player(root) , depende de si hay movimiento o no&#10;        if (_state != CharacterState.Attack &amp;&amp; _state != CharacterState.Dash)&#10;        {&#10;            float x;&#10;            _isMoving = !IsNearlyZero(_movement);&#10;&#10;            if (_isMoving)&#10;            {&#10;                //flip depende de la dirección de movimiento(en movimiento)&#10;                x = _movement.x;&#10;            }&#10;            else&#10;            {&#10;                //flip depende del ratón ( en idle)&#10;                x = _animDir.x;&#10;            }&#10;&#10;            if (x &lt; -0.01f)&#10;            {&#10;                spriteRenderer.flipX = true;//izq&#10;            }&#10;            else if (x &gt; 0.01f)&#10;            {&#10;                spriteRenderer.flipX = false;//der&#10;            }&#10;        }&#10;&#10;        //elige la direccion y luego reproduce el clip de ese lado &#10;&#10;        if (_state == CharacterState.Idle || _state == CharacterState.Walk)&#10;        {&#10;            _isMoving = !IsNearlyZero(_movement);&#10;&#10;            if (!_isMoving)&#10;            {&#10;                //idle se decide por raton&#10;                int idleTarget;&#10;                bool aimVertical = IsVerticalDominant(_animDir);&#10;                if (aimVertical)&#10;                {&#10;                    idleTarget = (_animDir.y &gt;= 0f) ? _idleBackAnimState : _idleFrontAnimState;&#10;                }&#10;                else&#10;                {&#10;&#10;                    idleTarget = _idleAnimState; //flipX a la izq&#10;                }&#10;&#10;                //si no esta en idle&#10;                if (_state != CharacterState.Idle)&#10;                {&#10;                    _state = CharacterState.Idle;&#10;                    CrossFadeSafe(idleTarget, _idleAnimState, 0.2f);&#10;                    _currentLocomotionHash = idleTarget;&#10;                }&#10;                else&#10;                {&#10;                    // en idle mira la dir de  raton(arriba o abajo)&#10;                    if (_currentLocomotionHash != idleTarget)&#10;                    {&#10;                        CrossFadeSafe(idleTarget, _idleAnimState, 0.2f);&#10;                        _currentLocomotionHash = idleTarget;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                //walk se decide por movimiento del teclado&#10;                int walkTarget;&#10;                bool moveVertical = IsVerticalDominant(_movement);&#10;                if (moveVertical)&#10;                {&#10;                    walkTarget = (_movement.y &gt;= 0f) ? _walkBackAnimState : _walkFrontAnimState;&#10;                }&#10;                else&#10;                {&#10;                    //&#10;                    walkTarget = _walkAnimState; //flipXva a la izq&#10;                }&#10;&#10;                if (_state != CharacterState.Walk)&#10;                {&#10;                    _state = CharacterState.Walk;&#10;                    CrossFadeSafe(walkTarget, _walkAnimState, 0.2f);&#10;                    _currentLocomotionHash = walkTarget;&#10;                }&#10;                else&#10;                {&#10;                    // en walk, cambia de vertical a horizontal o alrevés&#10;                    if (_currentLocomotionHash != walkTarget)&#10;                    {&#10;                        CrossFadeSafe(walkTarget, _walkAnimState, 0.1f);&#10;                        _currentLocomotionHash = walkTarget;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;&#10;    private void FixedUpdate()&#10;    {&#10;        if (_state == CharacterState.Hurt || _state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;        if (_state == CharacterState.Attack)&#10;        {&#10;            _rb.linearVelocity = Vector2.zero;//durante el ataque no se mueve el player&#10;        }&#10;        else if (!_isDashing)&#10;        {&#10;            _rb.linearVelocity = _movement * moveSpeed;&#10;        }&#10;&#10;    }&#10;&#10;    //DASH&#10;    //En la animacion de prueba del dash hace un frontflip&#10;    //Dash del player&#10;    private void OnDashInput()&#10;    {&#10;        if (!_canDash || _state == CharacterState.Attack || _state == CharacterState.Hurt || _state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;&#10;        StartCoroutine(Dash());&#10;    }&#10;&#10;&#10;&#10;    private IEnumerator Dash()&#10;    {&#10;        _isDashing = true;&#10;        _canDash = false;&#10;&#10;        //anim del dash segun dir&#10;        _state = CharacterState.Dash;&#10;&#10;        bool verticalDominant = Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x);&#10;        int dashTarget;&#10;&#10;        if (verticalDominant)&#10;        {&#10;            dashTarget = (_animDir.y &gt;= 0f) ? _dashBackAnimState : _dashFrontAnimState;&#10;        }&#10;        else&#10;        {&#10;            dashTarget = _dashAnimState;&#10;        }&#10;&#10;        CrossFadeSafe(dashTarget, _dashAnimState, 0f);&#10;&#10;&#10;        _rb.linearVelocity = _movement * dashSpeed;//dash&#10;        yield return new WaitForSeconds(dashCooldown);&#10;        _isDashing = false;&#10;&#10;        //vuelve a idle o walk segun teclado&#10;        if (_movement == Vector2.zero)&#10;        {&#10;            _state = CharacterState.Idle;&#10;            anim.CrossFadeInFixedTime(_idleAnimState, 0.1f);&#10;            _rb.linearVelocity = Vector2.zero;&#10;        }&#10;        else&#10;        {&#10;            _state = CharacterState.Walk;&#10;            anim.CrossFadeInFixedTime(_walkAnimState, 0.1f);&#10;            _rb.linearVelocity = _movement * moveSpeed;&#10;        }&#10;&#10;&#10;        _canDash = true;&#10;    }&#10;&#10;&#10;    //ATTACKS&#10;&#10;    public override void Attack()&#10;    {&#10;        Attack1();&#10;    }&#10;&#10;&#10;    private void Attack1()//ataque meele&#10;    {&#10;        if (!_isAttack || _state == CharacterState.Attack || _state == CharacterState.Die) return;&#10;&#10;        _state = CharacterState.Attack;&#10;        _isAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;&#10;        //elige animacion segun dir del raton&#10;        bool verticalDominant = false;&#10;        if (Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x))&#10;        {&#10;            verticalDominant = true;&#10;        }&#10;&#10;        int atk1Target;&#10;&#10;        if (verticalDominant)&#10;        {&#10;            atk1Target = (_animDir.y &gt;= 0f) ? _attack1BackAnimState : _attack1FrontAnimState;&#10;&#10;        }&#10;        else&#10;        {&#10;            atk1Target = _attack1AnimState;////&#10;        }&#10;&#10;        CrossFadeSafe(atk1Target, _attack1AnimState, 0f);&#10;&#10;        //hitbox melee&#10;        if (hitAnchor)&#10;        {&#10;            Vector2 forward;&#10;&#10;            if (_animDir.sqrMagnitude &gt; 0.0001f)&#10;            {&#10;                forward = _animDir;&#10;            }&#10;            else&#10;            {&#10;                if (spriteRenderer.flipX)&#10;                {&#10;                    forward = Vector2.left;&#10;                }&#10;                else&#10;                {&#10;                    forward = Vector2.right;&#10;                }&#10;                  &#10;            }&#10;&#10;            float forwardOffset = 0.4f;&#10;&#10;            Vector2 center = (Vector2)hitAnchor.position + forward * forwardOffset;&#10;            float angleDeg = Mathf.Atan2(forward.y, forward.x) * Mathf.Rad2Deg;&#10;&#10;            Collider2D[] results = Physics2D.OverlapBoxAll(center, hitSize, angleDeg);&#10;&#10;            foreach (var col in results)&#10;            {&#10;                if (col.CompareTag(&quot;Enemy&quot;))&#10;                {&#10;                    //mira si es un character&#10;                    Character enemyChar = col.GetComponentInParent&lt;Character&gt;();&#10;&#10;                    if (enemyChar != null)&#10;                    {&#10;                        //enemigo recibe danio&#10;                        enemyChar.TakeDamage(GetDamage());&#10;&#10;                    }&#10;                }&#10;            }&#10;            &#10;            StartCoroutine(WaitForAnimationToEnd(atk1Target));&#10;        }&#10;    }&#10;&#10;    //Ataque a distancia&#10;    private void Attack2()&#10;    {&#10;        if (!_isAttack || _state == CharacterState.Attack || _state == CharacterState.Die) return;&#10;&#10;        _state = CharacterState.Attack;&#10;        _isAttack = false;&#10;        _rb.linearVelocity = Vector2.zero;&#10;&#10;        bool verticalDominant = Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x);&#10;        int atk2Target;&#10;&#10;        if (verticalDominant)&#10;        {&#10;            if (_animDir.y &gt;= 0f)&#10;            {&#10;                atk2Target = _attack2BackAnimState;&#10;            }&#10;            else&#10;            {&#10;                atk2Target = _attack2FrontAnimState;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            atk2Target = _attack2AnimState;&#10;        }&#10;&#10;        // Calcular la dirección hacia el puntero del ratón justo antes de disparar&#10;        Vector3 mouseWorld = InputManager.Instance.GetPointerWorldPosition();&#10;        Vector2 shootDir = (mouseWorld - transform.position).sqrMagnitude &gt; 0.0001f ? (mouseWorld - transform.position).normalized : Vector2.right;&#10;        &#10;        //Llamada al spawner&#10;        ProjectileSpawner spawner = GetComponent&lt;ProjectileSpawner&gt;();&#10;        if (spawner != null)&#10;        {&#10;            spawner.SpawnProjectile(shootDir);&#10;        }&#10;        &#10;        CrossFadeSafe(atk2Target, _attack2AnimState, 0f);&#10;        StartCoroutine(WaitForAnimationToEnd(atk2Target));&#10;    }&#10;&#10;&#10;    //TAKEDAMAGE O HIT&#10;    //overrides de character&#10;    public override void TakeDamage(float dmg)&#10;    {&#10;&#10;        if (_state == CharacterState.Dash || _isDashing)&#10;        {&#10;            return;&#10;        }&#10;&#10;        if (_state == CharacterState.Die)&#10;        {&#10;            return;&#10;        }&#10;&#10;        SetHealthActual(GetHealthActual() - dmg);&#10;&#10;        if (GetHealthActual() &lt;= 0f)&#10;        {&#10;            _state = CharacterState.Die;&#10;            _rb.linearVelocity = Vector2.zero;&#10;&#10;            bool verticalDominant = false;&#10;            if (Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x))&#10;            {&#10;                verticalDominant = true;&#10;            }&#10;&#10;            int deathTarget;&#10;&#10;            if (verticalDominant)&#10;            {&#10;                deathTarget = (_animDir.y &gt;= 0f) ? _deathBackAnimState : _deathFrontAnimState;&#10;&#10;            }&#10;            else&#10;            {&#10;                deathTarget = _deathFrontAnimState;&#10;            }&#10;&#10;            CrossFadeSafe(deathTarget, _deathAnimState, 0f);&#10;        }&#10;        else&#10;        {&#10;            _state = CharacterState.Hurt;&#10;            _isAttack = false;&#10;            _rb.linearVelocity = Vector2.zero;&#10;&#10;            //elegir front o back segun el raton&#10;            bool verticalDominant = false;&#10;            if (Mathf.Abs(_animDir.y) &gt;= Mathf.Abs(_animDir.x))&#10;            {&#10;                verticalDominant = true;&#10;            }&#10;&#10;            int hitTarget; // fallback genérico&#10;&#10;            if (verticalDominant)&#10;            {&#10;                hitTarget = (_animDir.y &gt;= 0f) ? _hitBackAnimState : _hitFrontAnimState; // arriba : abajo&#10;&#10;            }&#10;            else&#10;            {&#10;                hitTarget = _hitAnimState;//horizontal&#10;            }&#10;&#10;            CrossFadeSafe(hitTarget, _hitAnimState, 0f);&#10;&#10;            //espera al hit segun fallback&#10;            StartCoroutine(WaitForAnimationToEnd(hitTarget, _hitAnimState));&#10;        }&#10;    }&#10;&#10;&#10;    //DEATH&#10;    public override void Die()&#10;    {&#10;        Debug.Log(&quot;Player muerto&quot;);&#10;        //TODO:codigo reiniciar todas las escenas si muere&#10;        //TODO:lanzar escena o UI de Game over&#10;    }&#10;&#10;    //ANIMACIONES&#10;    //espera a que acabe las animaciones (espera al fallback),para estar en idle&#10;    private IEnumerator WaitForAnimationToEnd(int preferredState, int fallbackState)&#10;    {&#10;        AnimatorStateInfo stateInfo = anim.GetCurrentAnimatorStateInfo(0);&#10;&#10;        //espera al fallback&#10;        while (stateInfo.shortNameHash != preferredState &amp;&amp; stateInfo.shortNameHash != fallbackState)&#10;        {&#10;            yield return null;&#10;&#10;            stateInfo = anim.GetCurrentAnimatorStateInfo(0);&#10;        }&#10;&#10;        //espera a normalizarla y que la animacion finalice&#10;        while (stateInfo.normalizedTime &lt; 1f)&#10;        {&#10;            yield return null;&#10;&#10;            stateInfo = anim.GetCurrentAnimatorStateInfo(0);&#10;        }&#10;        //si muere ,deja el loop y no vuelve a idle&#10;        if (_state != CharacterState.Die)&#10;        {&#10;            _state = CharacterState.Idle;&#10;&#10;            anim.CrossFadeInFixedTime(_idleAnimState, 0f);&#10;            _isAttack = true;&#10;        }&#10;        &#10;    }&#10;&#10;    //ref de 1 parametro cuando no hay fallback&#10;    private IEnumerator WaitForAnimationToEnd(int animState)&#10;    {&#10;        return WaitForAnimationToEnd(animState, animState);&#10;    }&#10;&#10;&#10;    //cambia la animacion en caso de que no haya clip, para no colapsar (lo hace en caso de que falte o falle algun clip)&#10;    private void CrossFadeSafe(int preferredStateHash, int fallbackStateHash, float fade)&#10;    {&#10;        if (anim &amp;&amp; anim.runtimeAnimatorController &amp;&amp; anim.HasState(0, preferredStateHash))&#10;        {&#10;            anim.CrossFadeInFixedTime(preferredStateHash, fade);&#10;        }&#10;&#10;        else&#10;        {&#10;            anim.CrossFadeInFixedTime(fallbackStateHash, fade);&#10;        }&#10;&#10;    }&#10;&#10;    //Helpers para la dir del raton&#10;    private bool IsNearlyZero(Vector2 v)&#10;    {&#10;        return v.sqrMagnitude &lt; 0.0001f;//comprueba si el player esta quieto o no (cerca de 0)&#10;    }&#10;&#10;    private bool IsVerticalDominant(Vector2 v)//determina si se apunta mas arriba que a la izq/der&#10;    {//para poder decidir entre las animaciones&#10;        return Mathf.Abs(v.y) &gt;= Mathf.Abs(v.x);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Projectile.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Projectile.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;public class Projectile : MonoBehaviour&#10;{&#10;    private Vector2 _direction;&#10;    private float _speed;&#10;    private float _damage;&#10;    private Rigidbody2D _rb;&#10;    [SerializeField] private float lifeTime = 3f;&#10;&#10;    //Inicializacion desde el enemigo&#10;    public void Init(Vector2 direction, float speed, float damage)&#10;    {&#10;        _direction = direction.normalized;&#10;        _speed = speed;&#10;        _damage = damage;&#10;        if (_rb != null)&#10;        {&#10;            _rb.linearVelocity = _direction * _speed;&#10;        }&#10;    }&#10;&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (_rb != null)&#10;            _rb.linearVelocity = Vector2.zero;&#10;    }&#10;&#10;    private void OnTriggerEnter2D(Collider2D collision)&#10;    {&#10;        //Los proyectiles hacen danio al jugador&#10;        if (collision.CompareTag(&quot;Player&quot;))&#10;        {&#10;            Character playerChar = collision.GetComponentInParent&lt;Character&gt;();&#10;            if (playerChar != null)&#10;                playerChar.TakeDamage(_damage);&#10;            DestroyProjectile();&#10;        }&#10;        //TODO: Los proyectiles dañan a otros enemigos&#10;        //Se destruyen si choca con algo que no sea enemigo o jugador&#10;        else if (!collision.CompareTag(&quot;Enemy&quot;))&#10;        {&#10;            DestroyProjectile();&#10;        }&#10;    }&#10;&#10;    public void DestroyProjectile()&#10;    {&#10;        gameObject.SetActive(false);&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class Projectile : MonoBehaviour&#10;{&#10;    private Vector2 _direction;&#10;    private float _speed;&#10;    private float _damage;&#10;    private Rigidbody2D _rb;&#10;    [SerializeField] private float lifeTime = 3f;&#10;&#10;    //Inicializacion desde el enemigo&#10;    public void Init(Vector2 direction, float speed, float damage)&#10;    {&#10;        _direction = direction.normalized;&#10;        _speed = speed;&#10;        _damage = damage;&#10;        if (_rb != null)&#10;        {&#10;            _rb.linearVelocity = _direction * _speed;&#10;        }&#10;    }&#10;&#10;    private void Awake()&#10;    {&#10;        _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (_rb != null)&#10;            _rb.linearVelocity = Vector2.zero;&#10;    }&#10;&#10;    private void OnTriggerEnter2D(Collider2D collision)&#10;    {&#10;        //Los proyectiles hacen danio al jugador&#10;        if (collision.CompareTag(&quot;Player&quot;))&#10;        {&#10;            Character playerChar = collision.GetComponentInParent&lt;Character&gt;();&#10;            if (playerChar != null)&#10;                playerChar.TakeDamage(_damage);&#10;            DestroyProjectile();&#10;        }&#10;        //TODO: Los proyectiles dañan a otros enemigos&#10;        //Se destruyen si choca con algo que no sea enemigo o jugador&#10;        else if (!collision.CompareTag(&quot;Enemy&quot;))&#10;        {&#10;            DestroyProjectile();&#10;        }&#10;    }&#10;&#10;    public void DestroyProjectile()&#10;    {&#10;        gameObject.SetActive(false);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/ProjectileSpawner.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con dirección, velocidad y daño&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;/*&#10; Este codigo es el que se encarga de instanciar los proyectiles&#10; */&#10;public class ProjectileSpawner : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform projectilePool;&#10;&#10;    [SerializeField] private Transform activeProjectilePool;&#10;&#10;    [SerializeField] private Transform spawnPoint;&#10;&#10;    [SerializeField] private GameObject projectilePrefab;&#10;&#10;    [SerializeField] private float projectileLifeTime, despawnLifetime;&#10;&#10;    [SerializeField] private float fireRate;&#10;&#10;    [SerializeField] private float projectileSpeed = 10f;&#10;    [SerializeField] private float projectileDamage = 1f;&#10;&#10;    private bool _canSpawn = true;&#10;    &#10;    private void Start()&#10;    {&#10;        InputManager.Instance.AttackDistancePerformed += OnAttackDistance;&#10;    }&#10;&#10;    //gestiona si necesita crear nuevas instancias o reactivar instancias &quot;durmientes&quot; o si esta en cooldown&#10;    private void OnAttackDistance()&#10;    {&#10;        if (!_canSpawn) return;&#10;&#10;        _canSpawn = false;&#10;        StartCoroutine(SpawnCooldown());&#10;&#10;        GameObject projectile;&#10;&#10;        if (projectilePool.childCount &lt;= 0)&#10;        {&#10;            projectile = Instantiate(projectilePrefab, spawnPoint.position, spawnPoint.rotation);&#10;        }&#10;        else&#10;        {&#10;            projectile = projectilePool.GetChild(0).gameObject;&#10;            projectile.transform.position = spawnPoint.position;&#10;            projectile.SetActive(true);&#10;        }&#10;        projectile.transform.SetParent(activeProjectilePool);&#10;        StartCoroutine(DestroyProjectile(projectile.GetComponent&lt;Projectile&gt;()));&#10;    }&#10;&#10;    public void SpawnProjectile(Vector2 direction)&#10;{&#10;    if (!_canSpawn) return;&#10;    _canSpawn = false;&#10;    StartCoroutine(SpawnCooldown());&#10;&#10;    GameObject projectile;&#10;    if (projectilePool.childCount &lt;= 0)&#10;    {&#10;        projectile = Instantiate(projectilePrefab, spawnPoint.position, Quaternion.identity);&#10;    }&#10;    else&#10;    {&#10;        projectile = projectilePool.GetChild(0).gameObject;&#10;        projectile.transform.position = spawnPoint.position;&#10;        projectile.SetActive(true);&#10;    }&#10;    projectile.transform.SetParent(activeProjectilePool);&#10;    // Inicializar el proyectil con dirección, velocidad y daño&#10;    Projectile projScript = projectile.GetComponent&lt;Projectile&gt;();&#10;    if (projScript != null)&#10;    {&#10;        projScript.Init(direction, projectileSpeed, projectileDamage);&#10;        StartCoroutine(DestroyProjectile(projScript));&#10;    }&#10;}&#10;&#10;    //lo que gestiona cada cuanto se puede disparar&#10;    private IEnumerator SpawnCooldown()&#10;    {&#10;        yield return new WaitForSeconds(fireRate); //fireRate es lo que lo limita, si se quiere cambiar modificar la variable&#10;        _canSpawn = true;&#10;    }&#10;&#10;    //gestiona la vida util del proyectil&#10;    private IEnumerator DestroyProjectile(Projectile projectile)&#10;    {&#10;        yield return new WaitForSeconds(projectileLifeTime);&#10;        if (projectile != null &amp;&amp; projectile.gameObject.activeSelf)&#10;        {&#10;            projectile.DestroyProjectile();&#10;        }&#10;        yield return new WaitForSeconds(despawnLifetime);&#10;        if (projectile != null)&#10;        {&#10;            projectile.gameObject.SetActive(false);&#10;            projectile.transform.SetParent(projectilePool);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>